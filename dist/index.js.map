{"version":3,"sources":["../src/MazeGenerator.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import MazeCell from './MazeCell';\nimport Direction from './directions.js';\n\nexport default class MazeGenerator {\n    constructor(width, height, start = [0, 0]) {\n        this._width = width;\n        this._height = height;\n        this._maze = [];\n        this._stack = [];\n        this._start = start;\n    }\n\n    get Width() {\n        return this._width;\n    }\n\n    get Height() {\n        return this._height;\n    }\n\n    get Start() {\n        return this._start;\n    }\n\n    set Start(x) {\n        this._start = [x[0], x[1]];\n    }\n\n    /**\n     * @return {array} Array of length Width*Height with MazeCell instances\n     */\n    get Maze() {\n        return this._maze;\n    }\n\n    /**\n     * @param x {int} Horizontal position\n     * @param y {int} Vertical position\n     * @param direction {direction} Direction\n     * @return {MazeCell} Neighbouring cell or null\n     * @throws {Error} If an invalid direction is specified\n     */\n    getNeighbour(x, y, direction) {\n        switch (direction) {\n            case Direction.LEFT:\n                return x > 0 ? this.getCell(x - 1, y) : null;\n            case Direction.RIGHT:\n                return x < this.Width - 1 ? this.getCell(x + 1, y) : null;\n            case Direction.UP:\n                return y > 0 ? this.getCell(x, y - 1) : null;\n            case Direction.DOWN:\n                return y < this.Height - 1 ? this.getCell(x, y + 1) : null;\n            default:\n                throw new Error(\"No such direction:\" + direction);\n        }\n    }\n\n    /**\n     * @param x {int} Horizontal position\n     * @param y {int} Vertical position\n     * @return {MazeCell} The maze cell located at x,y\n     */\n    getCell(x, y) {\n        if (x < 0 || y < 0 || x > this.Width - 1 || y > this.Height - 1) {\n            return null;\n        }\n        let cell = this._maze[y * this.Width + x];\n        if (!cell) {\n            cell = new MazeCell(x, y);\n            this._setCell(x, y, cell);\n        }\n        return cell;\n    }\n\n    /**\n     * Generates the maze, given a seed.\n     * @returns {array} Array of MazeCell instances\n     */\n    generate() {\n        this._stack = [];\n        this._maze = [];\n        let currentCell = this.getCell(this.Start[0], this.Start[1]);\n        currentCell.Visited = true;\n        this._gen_next(currentCell);\n        return this.Maze;\n    }\n\n\n    /**\n     * Returns the opposing direction for given direction\n     */\n    opposingDir(dir) {\n        switch (dir) {\n            case Direction.LEFT:\n                return Direction.RIGHT;\n            case Direction.RIGHT:\n                return Direction.LEFT;\n            case Direction.UP:\n                return Direction.DOWN;\n            case Direction.DOWN:\n                return Direction.UP;\n        }\n    }\n\n    /**\n     * Returns true if moving in a certain direction from a cell is possible.\n     * @param cell {MazeCell} The cell\n     * @param dir {direction} Any of DIR_LEFT, DIR_RIGHT, DIR_UP or DIR_DOWN\n     */\n    cellDirectionOpen(cell, dir) {\n        if (!cell.HasWall(dir)) {\n            let neigh = this.getNeighbour(cell.X, cell.Y, dir);\n            if (neigh === null) {\n                console.log(\"no cell neigh\", cell);\n                return false; // \"out of bounds\"\n            }\n            let odir = this.opposingDir(dir);\n            //console.log('dir,odir',dir,odir);\n            if (neigh.HasWall(odir)) {\n                throw new Error(\"Should not be possible\");\n            }\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @private\n     */\n    _gen_next(currentCell) {\n        let picked = this._pickNeighbour(currentCell);\n        if (picked) {\n            this._stack.push(currentCell);\n            currentCell.RemoveWall(picked.dir);\n            picked.neigh.RemoveWall(this.opposingDir(picked.dir));\n            picked.neigh.Visited = true;\n            this._gen_next(picked.neigh);\n        }\n        else {\n            picked = this._stack.pop();\n            if (picked) {\n                this._gen_next(picked);\n            } // else stack empty == Done!\n        }\n    }\n\n    /**\n     * @private\n     */\n    _setCell(x, y, cell) {\n        this._maze[y * this.Width + x] = cell;\n        return cell;\n    }\n\n    /**\n     * @private\n     */\n    _pickNeighbour(cell) {\n        const allDirs = Direction.ALL;\n        let canPick = allDirs\n            .map(d => {\n                return {\n                    dir: d,\n                    neigh: this.getNeighbour(cell.X, cell.Y, d)\n                };\n            })\n            .filter(n => {\n                return n.neigh !== null;\n            })\n            .filter(n => {\n                return !n.neigh.Visited;\n            });\n\n        if (canPick.length === 0) {\n            return null;\n        }\n        let pickDir = ~~(Math.random() * canPick.length);\n        let picked = canPick[pickDir];\n        return picked;\n    }\n}\n"]}